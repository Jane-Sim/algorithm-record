// 계단 오르기 (동적계획법 DP)
/**
 * 시작점에서 계단을 오르며 도착계단까지 가는 게임.
 * 각 계단에는 점수가 있다. 계단을 밟으면 해당 계단의 점수를 얻는다.
 * 계단 오르기 게임에서 '얻을 수 있는' 총 점수의 '최댓값'을 구하라
 *
 * 입력의 첫 번째 줄에는 계단의 갯수, 두 번째 줄에는 1단계부터의 점수 ...
 * 계단의 갯수는 300개 이하의 자연수, 계단 점수는 10,000이하의 자연수.
 *
 *
 * [계단 오르기 규칙]
 * 1. 계단 한 번에 한 계단 or 두 계단씩 오를 수 있다.
 * 2. 1칸씩 올갈 때, 연속된 세 개의 계단을 모두 밟으면 안된다. 2계단만 연속 오를 수 있음.(땅지점인 시작점은 제외)
 * 3. 마지막 도착 계단은 무조건 밟아야한다.
 *
 * ex) 첫 계단을 밟고 2계단 or 3계단으로 오르기 가능.
 * 그러나 1계단에서 4계단까지 다음 다음 다음인 세 계단씩 오르기는 안됌.
 * 마찬가지로 1계단에서, 2계단, 3계단으로 연속 오르기는 불가능하다.
 *
 *                                  도착계단
 *                                 -ㅡㅡㅡㅡ
 *                           3계단 ㅣ  20  ㅣ
 *                          ㅡㅡㅡ ㅣ      ㅣ
 *                   2계단 ㅣ  15  ㅣ      ㅣ
 *           1계단 ㅣ------ㅣ      ㅣ      ㅣ
 *  시작점  ㅡㅡㅡㅡㅣ  20  ㅣ      ㅣ      ㅣ
 * -------ㅣ  10   ㅣ      ㅣ      ㅣ      ㅣ
 *
 * 중요 포인트는, 도착 계단에 도달할 때, 1. 전 계단에서 올라오거나, 2. 전전 계단에서 올라오는 방향인 것이다.
 *
 * 1번째 방법은, 도착계단의 점수 + 직전 단계의 점수 + 전 전 전 단계의 총 합의 최댓값 단계의 점수의 합으로 최댓값을 구할 수 있고,
 * 2전째 방법은, 도착계단의 점수 + 전전 단계의 총 합의 최댓값 단계의 점수로 최댓값을 구할 수 있다.
 */

// 계단 갯수인 num, 나머지 계단의 점수값인 arr.
const [num, ...stairs] = require("fs")
  .readFileSync("/dev/stdin")
  .toString()
  .trim()
  .split("\n")
  .map((v) => +v);

// 각 계단의 점수를 저장할 배열을 생성해주자.
let dp = new Array(num).fill(0);

// 첫 번째 계단의 점수를 지정.
dp[0] = stairs[0];

// 두 번째 계단을 지정하는데, 시작점에서 두 번째 계단으로 바로 올라왔을 때와,
// 첫 번째 계단을 밟고 두 번째 계단을 밟았을 때의 총 점수를 비교하여 최댓값을 저장한다.
dp[1] = Math.max(stairs[1], stairs[0] + stairs[1]);

// 마찬가지로 세 번째 계단의 최댓값을 구할 때, 첫 번째 계단을 밟고 세 번째 계단을 왔을 때와, 두 번째 계단을 밟고 세 번째 계단을 밟을때의 최댓값을 비교한다.
// 세 번째 계단까지는 연산된 dp의 값을 사용하지 않고, stairs에서 점수를 꺼내어 사용하므로, 미리 지정하여 연산한다.
dp[2] = Math.max(stairs[0] + stairs[2], stairs[1] + stairs[2]);

// 네 번째 계단부터는 dp 배열에 저장된 값들과, 해당 계단의 값을 더하면서 1번 방법과 2번 방법 중 최댓값을 비교하여 배열에 저장한다.
for (let i = 3; i <= num; i++) {
  dp[i] = Math.max(
    // 해당 계단 점수 + 전 계단 점수 + 전전전 계단의 총 합인 최댓값 점수
    stairs[i] + stairs[i - 1] + dp[i - 3],
    // 해당 계단 점수 + 전전 계단의 총 합인 최댓값 점수
    stairs[i] + dp[i - 2]
  );
}
console.log(dp[num - 1]);
