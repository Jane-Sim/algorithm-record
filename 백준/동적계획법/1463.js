// 1로 만들기 (동적계획법 DP)
/**
 * 정수 X 값을 아래의 3개의 조건들로 1을 만들 때, 연산된 '최솟값' 구하기.
 * 1. X가 3으로 나눠지면 3으로 나누고, 2. 마찬가지로 2로 나누고, 3. 1을 뺀다.
 *
 * 주의할 점: 위의 조건 중 하나만 쓰는게 아니라, '각 조건들로 1을 구할 때' 가장 작은 최솟값이 무엇인지를 파악해야한다.
 *
 * 만약 X가 10일 때, 10은 2와 3으로 나눠지지 않는다. 1을 뺀다. 10 -> 9
 * 9는 3으로 나눠진다. 9 -> 3
 * 3도 3으로 나눠진다. 3 -> 1
 * 총 3번의 연산 값이 나온다.
 *
 * 그렇다면 X가 12일 때는? 12는 2와 3으로 나눠진다. 2로 나누면, 12 -> 6 -> 2 -> 1 / 3으로 나누면, 12 -> 4 -> 2 -> 1 / 1을 빼면, 12 -> 11 -> 10 -> 5 -> 4 -> 2 -> 1.
 * 2와 3으로 나눌 때가 가장 최솟값이 적다.
 *
 * 위의 연산법을 보면 반복되는 연산동작들이 많다. 특히 1, 2, 3 .. 등 앞자리 숫자들은 1로 가기 위해 반복된다.
 * 3가지 조건을 통해 최솟값을 구해야 하기에 똑같은 연산을 작업. 해당 작업을 동적계획법을 이용하면 연산한 결과물을 배열에 저장하고, 해당 연산결과물이 필요할 때 배열에서 불러오면 된다.
 *
 * 동적계획법의 Bottom-up 방식을 이용하면 더 괜찮을 것 같다.
 */
let fs = require("fs");
let input = fs.readFileSync("/dev/stdin").toString().to(" ");
// 정수 X의 값.
let X = Number(input);

// 연산된 값을 저장할 배열. X의 크기만큼 배열의 길이를 정한다.
let result = new Array(X);
// 1은 연산이 필요없으므로 연산된 값을 0로 지정한다.
result[1] = 0;

// 1은 위에서 지정했으니, 2부터 포문을 돌며, 낮은 수의 값부터 연산을 하며 배열에 저장한다.
for (let i = 2; i <= X; i++) {
  // 3가지 조건의 최소 연산 수를 비교하기 위해, 조건들의 결과값을 저장하는 배열.
  let computes = [];

  // 3으로 나눌 수 있을 때, 3으로 나눠진 값의 인덱스를 통해 연산된 최소연산값을 가져온다. 그리고 연산 수를 1 더한다.
  // ex) i가 3일 때, 3/3은 1. result[1]의 연산값은 0. (불러온 연산값 0 + 현재 3이 연산 중이므로, 연산수를 1 더한다.) = 2.
  // ex) i가 9일 때, 9/3은 3. result[3]의 연산값은 2. (2 + 1) = 3.
  if (i % 3 === 0) {
    computes.push(result[i / 3] + 1);
  }
  if (i % 2 === 0) {
    computes.push(result[i / 2] + 1);
  }
  // 1을 뺀 값의 연산된 최솟값을 가져오고 + 현재 연산중이므로 1을 더한다.
  computes.push(result[i - 1] + 1);

  // 3으로 나눴거나 2로 나눴거나 1을 뺀 조건들의 각 연산수 중에서, 연산 최솟값을 해당 배열의 값으로 지정한다.
  result[i] = Math.min(...computes);
}

// X 정수의 연산 최솟값을 불러온다.
console.log(result[X]);

// ---------------------------------------------------------------------

// 아래는 다른 개발자의 코드를 더 참고하여 해석해봤다. 위의 코드의 메모리와 시간 사용률이 절반정도 줄어든다.

const input = require("fs").readFileSync("/dev/stdin").toString();
const num = Number(input);
// X의 크기만큼 배열을 만드는데, 이때 각 배열은 0값을 갖는다.
const X = new Array(num + 1).fill(0);

// 똑같이 2부터 포문을 돈다.
for (let i = 2; i <= num; i++) {
  // 1을 뺀 값의 연산된 최솟값을 가져와, 해당 배열에 저장한다.
  X[i] = X[i - 1] + 1;

  // 만약 2로 나눌 수 있을 때, 해당 배열에 저장된 1을 뺀 값의 연산최솟값과, 2로 나눴을 때의 값의 연산최솟값을 비교해 더 적은 연산최솟값을 해당 배열에 다시 저장한다.
  if (i % 2 === 0) {
    X[i] = Math.min(X[i], X[i / 2] + 1);
  }
  // 만약 3으로 나눌 수 있을 때, 1을 빼거나 2로 나눠져서 구해진 연산최솟값이 저장된 해당 배열의 값과, 3으로 나눴을 때의 값의 연산최솟값을 비교해 더 적은 연산최솟값을 해당 배열에 다시 저장한다.
  if (i % 3 === 0) {
    X[i] = Math.min(X[i], X[i / 3] + 1);
  }
}

// X 정수의 연산 최솟값을 불러온다.
console.log(X[num]);
